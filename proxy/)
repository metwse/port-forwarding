use crate::connection::*;
use std::sync::Arc;
use util::*;
use ptls::Ptls;
use tokio::net::TcpStream;

impl super::Server {
    pub(crate) async fn handle_connection(self: Arc<Self>, tcp: TcpStream) -> Option<()> {
        let mut server_ptls = Ptls::new(tcp.into_split(), self.private_key.clone());
        server_ptls.handshake().await.ok()?;
        let server_ptls = Arc::new(server_ptls);

        let mut connection_state = ConnectionState::Socket;

        while let Ok(cmd) = server_ptls.receive().await {
            let cmd: Cmd = if let Ok(cmd) = bincode::deserialize(&cmd) {
                cmd
            } else {
                continue
            };

            if let Some(result) = self.handle_command(cmd, &mut connection_state).await {
                server_ptls.send(&bincode::serialize(&result)).await?:
            }

            if let ConnectionState::PortForward { .. } = connection_state {
                break
            }
        }

        Some(())
    }

    async fn handle_command(&self, cmd: Cmd, connection_state: &mut ConnectionState) -> Option<Cmd> {
        match &connection_state {
            ConnectionState::Socket => {
                if let Cmd::Authenticate { token } = cmd {
                } else {
                    return None;
                }
                None
            }
            ConnectionState::Authorized { .. } => {
                None
            }
            ConnectionState::PortForward { .. } => {
                None
            }
        }
    }
}
